#!/usr/bin/env python

# To test this recipe run:
# source ~/.pinboard.conf && ebook-convert pinboard-to-kindle.recipe test.mobi --output-profile kindle_pw3 --debug

__license__ = "MIT"
__copyright__ = "2020, Christian Hans"
__website__ = ""

#
# Config
#
## Maximum number of unread Pinboard bookmarks to download
MAX_ARTICLES = 50

## If set, the recipe will only consider unread Pinboard bookmarks that have this tag
TOKINDLE_TAG = "tokindle"

## If set, the recipe will update all fetched Pinboard bookmarks and
## replace TOKINDLE_TAG with this tag
REPLACE_TOKINDLE_TAG = "sentkindle"

## Full file path to pinboard-to-kindle/fetch-article-moz-readability/index.js
FETCH_ARTICLE_MOZ_READABILITY_SCRIPT_PATH = ''

## Temporary folder to use for downloading bookmark's page content
FETCH_ARTICLE_TMP_PATH = '/tmp'

## Full file paths to Node and Pandoc binaries
NODE_BIN_FILE_PATH = '/usr/local/bin/node'

import os
import re
import urllib
import json
import subprocess
import uuid

class PinboardRecipe(BasicNewsRecipe):
    title = "Pinboard"
    description = "Generate an ebook of unread Pinboard bookmarks."
    __author__ = "Christian Hans"

    auto_cleanup = False
    no_stylesheets = True
    remove_javascript = True
    articles_are_obfuscated = True
    encoding = "utf8"

    downloaded_file_paths = {}

    def _get_pinboard_token(self):
        pinboard_token = os.environ.get("PINBOARD_TOKEN")
        if not pinboard_token:
            self.abort_recipe_processing(
                "Please set PINBOARD_TOKEN environment variable."
            )
        return pinboard_token

    def _get_bookmarks(self):
        params = urllib.urlencode(
            {
                "tag": TOKINDLE_TAG if TOKINDLE_TAG else "",
                "format": "json",
                "auth_token": self._get_pinboard_token(),
            }
        )
        response = urllib.urlopen("https://api.pinboard.in/v1/posts/all?" + params)
        bookmarks = json.loads(response.read())
        bookmarks = [b for b in bookmarks if (b["toread"] == "yes")]
        bookmarks = bookmarks[:MAX_ARTICLES]
        if len(bookmarks) == 0:
            self.abort_recipe_processing("No unread Pinboard bookmarks.")
        return bookmarks

    def _replace_tokindle_tag(self, bookmark):
        if (not TOKINDLE_TAG) or (not REPLACE_TOKINDLE_TAG):
            return
        tags = bookmark["tags"].split()
        if TOKINDLE_TAG in tags:
            tags.remove(TOKINDLE_TAG)
        tags.append(REPLACE_TOKINDLE_TAG)
        params = urllib.urlencode(
            {
                "url": bookmark["href"],
                "description": bookmark["description"],
                "extended": bookmark["extended"],
                "tags": " ".join(tags),
                "dt": bookmark["time"],
                "shared": bookmark["shared"],
                "toread": bookmark["toread"],
                "replace": "yes",
                "format": "json",
                "auth_token": self._get_pinboard_token(),
            }
        )
        urllib.urlopen("https://api.pinboard.in/v1/posts/add?" + params)

    def _fetch_article_moz_readability(self, url):
        downloaded_file_path = os.path.join(FETCH_ARTICLE_TMP_PATH, "{}.html".format(uuid.uuid1()))
        self.downloaded_file_paths[url] = downloaded_file_path

        print("Downloading: {}".format(url))
        subprocess.call([
            NODE_BIN_FILE_PATH,
            FETCH_ARTICLE_MOZ_READABILITY_SCRIPT_PATH,
            url,
            "--output_file={}".format(downloaded_file_path)
        ])

        return downloaded_file_path

    def _get_article_metadata(self, article_file_path):
        res = {}
        with open(article_file_path, "r") as f:
            html = f.read()
        match = re.search(
            '<[^>]+ id="pb-to-kindle-article-title">(.*?)</[^>]+>',
            html,
            re.IGNORECASE
        )
        if match:
            res["title"] = match.group(1)
        match = re.search(
            '<[^>]+ id="pb-to-kindle-article-metadata">(.*?)</[^>]+>',
            html,
            re.IGNORECASE
        )
        if match:
            res["metadata"] = match.group(1)
        return res

    def get_obfuscated_article(self, url):
        """ Let Calibre download images and other media in downloaded html files """
        return self.downloaded_file_paths.get(url)

    def parse_index(self):
        articles = []

        bookmarks = self._get_bookmarks()
        for bookmark in bookmarks:
            url = bookmark['href']
            try:
                article_file_path = self._fetch_article_moz_readability(url)
                article_info = self._get_article_metadata(article_file_path)
            except:
                print("Error fetching URL: {}".format(url))
                continue

            print("Updating Pinboard tags: {}".format(url))
            self._replace_tokindle_tag(bookmark)

            articles.append({
                "title": article_info.get('title', ''),
                "url": url,
                "description": article_info.get('metadata', ''),
                # "date": "February 20th, 2020",        
            })

        return [("Pinboard", articles)]

    def cleanup(self):
        for file_path in self.downloaded_file_paths.values():
            if not os.path.exists(file_path):
                continue
            print("Removing temporary file: {}".format(file_path))
            os.remove(file_path)